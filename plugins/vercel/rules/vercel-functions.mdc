---
description: Best practices for Vercel serverless and edge functions
globs:
  - "api/**/*.ts"
  - "app/api/**/*.ts"
  - "pages/api/**/*.ts"
alwaysApply: false
---

# Vercel Serverless & Edge Function Best Practices

## Runtime Selection

- **Use Edge Runtime** (`export const runtime = 'edge'`) for low-latency responses that don't require Node.js APIs. Edge functions run in Vercel's global edge network and have a ~25 ms cold-start.
- **Use Node.js Serverless Runtime** (default) when you need full Node.js compatibility, native modules, or long-running computation.
- Declare the runtime explicitly at the top of every route handler so the choice is intentional and documented.

```ts
// Edge Runtime — fast, globally distributed
export const runtime = 'edge';

// Node.js Serverless — full Node.js API access
export const runtime = 'nodejs';
```

## Function Duration & Timeouts

- Always set `maxDuration` for functions that may run longer than the default timeout (10 s on Hobby, 60 s on Pro, 900 s on Enterprise).
- Keep `maxDuration` as low as practical to avoid billing surprises and improve user experience.

```ts
export const maxDuration = 30; // seconds
```

- For very long operations, consider breaking work into smaller chunks, using background functions, or offloading to a queue (e.g., Vercel Cron + KV).

## Cold Start Mitigation

- Minimize top-level imports. Use dynamic `import()` for heavy dependencies that are only needed in certain code paths.
- Keep function bundles small — avoid importing entire SDKs when only a single utility is needed.
- Consider using Edge Runtime for latency-critical endpoints; edge functions have near-zero cold starts.
- Use `@vercel/functions` helpers like `waitUntil()` to defer non-critical work without blocking the response.

```ts
import { waitUntil } from '@vercel/functions';

export async function POST(request: Request) {
  const data = await request.json();
  const result = processData(data);

  // Fire-and-forget analytics — does not block the response
  waitUntil(logAnalytics(data));

  return Response.json(result);
}
```

## Streaming Responses

- Use streaming for LLM integrations, large datasets, or any response that benefits from progressive delivery.
- Prefer the Web Streams API (`ReadableStream`, `TransformStream`) over Node.js streams for portability across runtimes.

```ts
export async function GET() {
  const stream = new ReadableStream({
    async start(controller) {
      for (const chunk of generateChunks()) {
        controller.enqueue(new TextEncoder().encode(chunk));
      }
      controller.close();
    },
  });

  return new Response(stream, {
    headers: { 'Content-Type': 'text/plain; charset=utf-8' },
  });
}
```

## CORS Headers

- Set proper CORS headers for API routes that are called from browser clients.
- Handle `OPTIONS` preflight requests explicitly.
- Never use `Access-Control-Allow-Origin: *` in production for authenticated endpoints.

```ts
const corsHeaders = {
  'Access-Control-Allow-Origin': process.env.ALLOWED_ORIGIN || 'https://yourdomain.com',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  'Access-Control-Max-Age': '86400',
};

export async function OPTIONS() {
  return new Response(null, { status: 204, headers: corsHeaders });
}

export async function GET(request: Request) {
  const data = await fetchData();
  return Response.json(data, { headers: corsHeaders });
}
```

## Environment Variables

- **Never hardcode** secrets, API keys, database URLs, or environment-specific values.
- Access configuration exclusively via `process.env`.
- Use Vercel's Environment Variables UI or CLI (`vercel env add`) to manage values per environment (Production, Preview, Development).
- Validate required environment variables at the top of the function and return a clear error if missing.

```ts
export async function GET() {
  const apiKey = process.env.EXTERNAL_API_KEY;
  if (!apiKey) {
    console.error('EXTERNAL_API_KEY is not configured');
    return Response.json(
      { error: 'Server misconfiguration' },
      { status: 500 }
    );
  }
  // ... use apiKey
}
```

## Error Handling

- Always return proper HTTP status codes: `400` for bad input, `401`/`403` for auth errors, `404` for not found, `500` for server errors.
- Return structured JSON error bodies with a human-readable `error` field.
- Log errors with enough context for debugging but never expose internal details (stack traces, secrets) to the client.

```ts
export async function POST(request: Request) {
  try {
    const body = await request.json();

    if (!body.email) {
      return Response.json(
        { error: 'Email is required' },
        { status: 400 }
      );
    }

    const result = await createUser(body);
    return Response.json(result, { status: 201 });
  } catch (error) {
    console.error('Failed to create user:', error);
    return Response.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

## Vercel Storage Integration

- Use **Vercel KV** (Redis-compatible) for caching, session storage, rate limiting, and feature flags.
- Use **Vercel Blob** for file uploads and static asset storage.
- Use **Vercel Postgres** (Neon-backed) for relational data.
- Import storage clients from their respective `@vercel/*` packages and rely on automatic environment variable binding.

```ts
import { kv } from '@vercel/kv';

export async function GET(request: Request) {
  const url = new URL(request.url);
  const key = url.searchParams.get('key');

  const cached = await kv.get(key);
  if (cached) {
    return Response.json(cached);
  }

  const fresh = await expensiveComputation(key);
  await kv.set(key, fresh, { ex: 3600 }); // cache for 1 hour
  return Response.json(fresh);
}
```

## Input Validation & Security

- Validate and sanitize all incoming data (query params, body, headers) before processing.
- Use `zod`, `valibot`, or similar schema validation libraries for structured input.
- Set `Content-Security-Policy`, `X-Content-Type-Options`, and other security headers on responses.
- Rate-limit sensitive endpoints using Vercel KV or Vercel WAF.

## Route Handler Conventions (App Router)

- Export named functions matching HTTP methods: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `OPTIONS`, `HEAD`.
- Use the `NextRequest` type from `next/server` for enhanced request helpers (cookies, geo, IP).
- Return `NextResponse` or standard `Response` objects.
- Colocate route handlers in `app/api/` with `route.ts` files.

```ts
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const page = parseInt(searchParams.get('page') ?? '1', 10);

  const users = await getUsers({ page });
  return NextResponse.json(users);
}
```

## Performance Tips

- Return responses as early as possible; avoid unnecessary `await` chains.
- Use `waitUntil()` from `@vercel/functions` to defer logging, analytics, and cache warming.
- Set appropriate `Cache-Control` headers for GET endpoints that serve cacheable data.
- Use Incremental Static Regeneration (ISR) with `revalidate` instead of API routes for data that changes infrequently.
