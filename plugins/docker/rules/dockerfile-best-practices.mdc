---
description: Best practices for writing efficient, secure, and maintainable Dockerfiles
globs:
  - "Dockerfile*"
  - "*.dockerfile"
  - ".dockerignore"
alwaysApply: false
---

# Dockerfile Best Practices

## Multi-Stage Builds

- Always use multi-stage builds to separate build dependencies from runtime.
- Name each stage explicitly (e.g., `FROM node:20-alpine AS builder`).
- Copy only the artifacts needed for the final image from the build stage.
- Use a minimal base image for the final stage (e.g., `alpine`, `distroless`, `scratch`).

```dockerfile
# Example multi-stage build
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:20-alpine AS runtime
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
USER node
CMD ["node", "dist/index.js"]
```

## Pin Base Image Versions

- Always pin base image versions using tags AND digests for reproducible builds.
- Never use `:latest` in production Dockerfiles.
- Use build arguments (ARG) to parameterize versions for easier updates.

```dockerfile
ARG NODE_VERSION=20.11.0
FROM node:${NODE_VERSION}-alpine@sha256:abc123... AS builder
```

## Run as Non-Root User

- Always create and switch to a non-root user before running the application.
- Use the `USER` instruction after installing dependencies but before copying application code.
- If the base image provides a built-in non-root user (e.g., `node` in Node.js images), prefer that.

```dockerfile
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser
```

## Minimize Layers

- Combine related `RUN` instructions using `&&` to reduce the number of layers.
- Clean up package manager caches in the same `RUN` instruction where packages are installed.
- Each `RUN`, `COPY`, and `ADD` instruction creates a new layer — be intentional.

```dockerfile
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl ca-certificates && \
    rm -rf /var/lib/apt/lists/*
```

## Order Instructions by Change Frequency

- Place instructions that change least frequently at the top (base image, system deps).
- Copy dependency manifests (e.g., `package.json`, `requirements.txt`, `go.mod`) before copying the full source code.
- This maximizes Docker layer caching and speeds up rebuilds.

```dockerfile
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
```

## Use .dockerignore

- Always include a `.dockerignore` file to exclude unnecessary files from the build context.
- Exclude: `.git`, `node_modules`, `__pycache__`, `.env`, test files, documentation, IDE configs.
- A smaller build context means faster builds and smaller images.

## Use COPY Instead of ADD

- Prefer `COPY` over `ADD` for copying local files into the image.
- Only use `ADD` when you need its special features: extracting tarballs or fetching remote URLs.
- `COPY` is more explicit and predictable.

## Set HEALTHCHECK

- Define a `HEALTHCHECK` instruction so Docker can monitor container health.
- Use lightweight health check commands (e.g., `curl`, `wget`, or custom scripts).
- Configure appropriate intervals, timeouts, and retries.

```dockerfile
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1
```

## Use Specific WORKDIR

- Always set `WORKDIR` explicitly instead of relying on `cd` commands in `RUN`.
- Use absolute paths for `WORKDIR`.
- Prefer `/app` or `/home/<user>/app` as the working directory.

```dockerfile
WORKDIR /app
```

## Avoid Unnecessary Packages

- Use `--no-install-recommends` with `apt-get` to skip optional packages.
- Only install what is strictly needed for the application to run.
- Remove build tools in the final stage of multi-stage builds.

## Clean Up in the Same Layer

- Always clean up package manager caches in the same `RUN` instruction as the install.
- Deleting files in a subsequent layer does NOT reduce image size — the files remain in earlier layers.

```dockerfile
RUN apt-get update && \
    apt-get install -y --no-install-recommends build-essential && \
    make && make install && \
    apt-get purge -y build-essential && \
    apt-get autoremove -y && \
    rm -rf /var/lib/apt/lists/*
```

## Use Build Arguments for Versions

- Parameterize dependency versions using `ARG` instructions.
- This makes upgrades easier and more visible in code review.

```dockerfile
ARG PYTHON_VERSION=3.12
ARG PIP_VERSION=24.0
FROM python:${PYTHON_VERSION}-slim
```

## ENTRYPOINT vs CMD

- Use `ENTRYPOINT` for the main executable — the container's primary purpose.
- Use `CMD` for default arguments that can be overridden at runtime.
- Prefer the exec form (`["executable", "arg"]`) over the shell form to ensure proper signal handling.

```dockerfile
ENTRYPOINT ["node"]
CMD ["dist/index.js"]
```

## Additional Guidelines

- Set meaningful `LABEL` instructions for metadata (maintainer, version, description).
- Use `EXPOSE` to document which ports the application listens on.
- Avoid storing secrets in the image — use Docker secrets or environment variables at runtime.
- Scan images for vulnerabilities using tools like Trivy, Snyk, or Docker Scout.
- Prefer `COPY --chown=user:group` to avoid extra `RUN chown` layers.
