---
description: Best practices for Docker Compose configuration files
globs:
  - "docker-compose*.yml"
  - "docker-compose*.yaml"
  - "compose*.yml"
  - "compose*.yaml"
alwaysApply: false
---

# Docker Compose Best Practices

## Version and File Structure

- Use Compose Specification (no `version` key needed for Docker Compose v2+).
- Split configurations by environment using multiple compose files:
  ```
  compose.yaml           # Base services
  compose.override.yaml  # Local development overrides (auto-loaded)
  compose.prod.yaml      # Production overrides
  compose.test.yaml      # Testing overrides
  ```
- Use `docker compose -f compose.yaml -f compose.prod.yaml up` to layer configurations.

## Image Versioning

- **Pin image versions** — never use `latest` in compose files:
  ```yaml
  services:
    db:
      image: postgres:16.2-alpine  # Good
      # image: postgres:latest     # Bad
  ```
- For custom-built services, use explicit build contexts and targets:
  ```yaml
  services:
    api:
      build:
        context: .
        dockerfile: Dockerfile
        target: production
  ```

## Named Volumes for Persistence

- **Use named volumes** for any data that must persist across container restarts:
  ```yaml
  services:
    db:
      image: postgres:16.2-alpine
      volumes:
        - postgres_data:/var/lib/postgresql/data

  volumes:
    postgres_data:
      driver: local
  ```
- Avoid bind mounts in production. Use them only for development hot-reloading:
  ```yaml
  services:
    app:
      volumes:
        - ./src:/app/src  # Development only
  ```

## Resource Limits

- **Set memory and CPU limits** to prevent runaway containers:
  ```yaml
  services:
    api:
      deploy:
        resources:
          limits:
            cpus: "1.0"
            memory: 512M
          reservations:
            cpus: "0.25"
            memory: 128M
  ```

## Health Checks

- **Define health checks** for every service so dependent services can wait:
  ```yaml
  services:
    db:
      image: postgres:16.2-alpine
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U postgres"]
        interval: 10s
        timeout: 5s
        retries: 5
        start_period: 30s
  ```

## Service Dependencies

- Use `depends_on` with `condition` to control startup order based on health:
  ```yaml
  services:
    api:
      depends_on:
        db:
          condition: service_healthy
        redis:
          condition: service_healthy
  ```
- Never rely on `depends_on` alone without health check conditions — it only guarantees container start, not readiness.

## Environment Variables

- **Use `env_file`** to manage environment variables instead of inline `environment`:
  ```yaml
  services:
    api:
      env_file:
        - .env
        - .env.local
  ```
- Never commit `.env` files with secrets. Use `.env.example` as a template.
- Use variable substitution for dynamic values:
  ```yaml
  services:
    api:
      image: myapp:${APP_VERSION:-latest}
  ```

## Networking

- **Define custom networks** for service isolation:
  ```yaml
  services:
    api:
      networks:
        - frontend
        - backend
    db:
      networks:
        - backend

  networks:
    frontend:
      driver: bridge
    backend:
      driver: bridge
      internal: true  # No external access
  ```
- Use `internal: true` for backend networks that should not have internet access.
- Services on the same network can reach each other by service name (built-in DNS).

## Profiles for Optional Services

- Use **profiles** to group optional services that are not needed in every environment:
  ```yaml
  services:
    app:
      image: myapp:1.0
      # No profile — always starts

    debug:
      image: busybox
      profiles:
        - debug

    monitoring:
      image: grafana/grafana:10.3.1
      profiles:
        - monitoring

    mailhog:
      image: mailhog/mailhog:v1.0.1
      profiles:
        - dev
  ```
- Start optional services with `docker compose --profile debug up`.

## Logging

- Configure log drivers and limits to prevent disk exhaustion:
  ```yaml
  services:
    api:
      logging:
        driver: json-file
        options:
          max-size: "10m"
          max-file: "3"
  ```

## Restart Policies

- Set appropriate restart policies:
  ```yaml
  services:
    api:
      restart: unless-stopped  # Recommended for production
    worker:
      restart: on-failure
  ```

## Security

- Do not run containers as root. Use `user` directive:
  ```yaml
  services:
    api:
      user: "1000:1000"
  ```
- Mount secrets using Docker secrets or bind-mount read-only files:
  ```yaml
  secrets:
    db_password:
      file: ./secrets/db_password.txt

  services:
    db:
      secrets:
        - db_password
  ```
- Use `read_only: true` for containers that do not need to write to the filesystem.
- Drop unnecessary Linux capabilities with `cap_drop: [ALL]` and add only what is needed.

## Development Workflow

- Use `watch` for file-sync based hot-reloading (Compose v2.22+):
  ```yaml
  services:
    app:
      develop:
        watch:
          - action: sync
            path: ./src
            target: /app/src
          - action: rebuild
            path: package.json
  ```
- Use `docker compose watch` for automatic syncing without bind mounts.
