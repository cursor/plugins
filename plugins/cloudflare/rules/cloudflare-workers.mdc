---
description: Best practices for Cloudflare Workers and edge computing
globs:
  - "src/**/*.ts"
  - "src/**/*.js"
  - "worker*.*"
  - "**/workers/**"
alwaysApply: false
---

# Cloudflare Workers Best Practices

## Web Standard APIs

- **Use Web Standard APIs exclusively.** Workers run on the V8 isolate model, not Node.js. Use `fetch`, `Request`, `Response`, `Headers`, `URL`, `URLSearchParams`, `crypto` (Web Crypto API), `TextEncoder`, `TextDecoder`, `ReadableStream`, `WritableStream`, and `TransformStream`.
- Do **not** use Node.js built-ins (`fs`, `path`, `http`, `child_process`) unless you explicitly enable the `nodejs_compat` compatibility flag in `wrangler.toml`.
- Prefer `URLPattern` for URL routing instead of regex-based routers when possible.

```ts
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    if (path === "/api/data") {
      return handleData(request, env, ctx);
    }

    return new Response("Not Found", { status: 404 });
  },
};
```

## Error Handling

- Always wrap handler logic in `try/catch` and return a proper `Response` object — never let exceptions propagate unhandled.
- Return structured JSON error bodies with a human-readable `error` field and appropriate HTTP status codes (`400`, `401`, `403`, `404`, `500`).
- Log errors with `console.error()` for debugging via `wrangler tail` but never expose internal details (stack traces, binding names, secrets) to clients.

```ts
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    try {
      const data = await request.json();
      if (!data.name) {
        return Response.json({ error: "name is required" }, { status: 400 });
      }

      const result = await processData(data, env);
      return Response.json(result, { status: 200 });
    } catch (err) {
      console.error("Unhandled error:", err);
      return Response.json(
        { error: "Internal server error" },
        { status: 500 }
      );
    }
  },
};
```

## Choosing the Right Storage Binding

Select the correct Cloudflare storage primitive for each use case:

| Storage | Best For | Consistency | Limits |
|---|---|---|---|
| **KV** | Read-heavy, eventually consistent data (config, feature flags, cached content) | Eventual (global propagation ~60 s) | 25 MiB values, 512 B keys |
| **D1** | Relational data, complex queries, transactions | Strong (single-region) | SQLite-based, row-level |
| **R2** | Object/file storage (images, videos, backups, logs) | Strong | 5 TB per object, S3-compatible |
| **Durable Objects** | Stateful, real-time coordination (WebSocket servers, counters, sessions) | Strong (single-instance) | Co-located with clients |
| **Queues** | Async/background processing, task pipelines | At-least-once delivery | Batched consumption |
| **Hyperdrive** | Accelerating connections to existing Postgres databases | Pass-through | Connection pooling |

### KV — Read-Heavy Data

```ts
// Read from KV (fast, globally cached)
const value = await env.MY_KV.get("config:feature-flags", { type: "json" });

// Write to KV (eventually consistent)
await env.MY_KV.put("user:123:preferences", JSON.stringify(prefs), {
  expirationTtl: 86400, // 24 hours
});
```

### D1 — Relational Data

```ts
const { results } = await env.DB.prepare(
  "SELECT id, name, email FROM users WHERE active = ? ORDER BY created_at DESC LIMIT ?"
)
  .bind(1, 20)
  .all();
```

### R2 — Object Storage

```ts
// Upload a file
await env.BUCKET.put(`uploads/${crypto.randomUUID()}.png`, request.body, {
  httpMetadata: { contentType: "image/png" },
});

// Download a file
const object = await env.BUCKET.get("uploads/photo.png");
if (!object) return new Response("Not Found", { status: 404 });
return new Response(object.body, {
  headers: { "Content-Type": object.httpMetadata?.contentType ?? "application/octet-stream" },
});
```

### Durable Objects — Stateful Workloads

- Use Durable Objects when you need strongly consistent, single-threaded state (e.g., WebSocket rooms, counters, collaborative editing, rate limiters).
- Each Durable Object instance is globally unique and processes requests sequentially.
- Use the `storage` API inside the object for persistent, transactional key-value storage.

```ts
export class ChatRoom implements DurableObject {
  private sessions: WebSocket[] = [];

  constructor(private state: DurableObjectState, private env: Env) {}

  async fetch(request: Request): Promise<Response> {
    const pair = new WebSocketPair();
    this.state.acceptWebSocket(pair[1]);
    this.sessions.push(pair[1]);
    return new Response(null, { status: 101, webSocket: pair[0] });
  }

  async webSocketMessage(ws: WebSocket, message: string) {
    for (const session of this.sessions) {
      if (session !== ws) session.send(message);
    }
  }
}
```

### Queues — Async Processing

```ts
// Producer: send a message
await env.MY_QUEUE.send({ type: "email", to: "user@example.com", template: "welcome" });

// Consumer: process messages in batches
export default {
  async queue(batch: MessageBatch<EmailTask>, env: Env): Promise<void> {
    for (const message of batch.messages) {
      await sendEmail(message.body, env);
      message.ack();
    }
  },
};
```

## CPU Time Limits

- Workers have strict CPU time limits: **10 ms on the free plan** and **30 s on the paid plan** (Workers Paid / Workers for Platforms).
- CPU time does **not** include time spent waiting on I/O (`fetch`, KV reads, D1 queries). Only actual computation counts.
- Keep Workers small and focused. Offload heavy computation to Queues or Durable Objects.
- Profile CPU usage with `wrangler dev --local` and the Chrome DevTools profiler.

## Background Tasks with `waitUntil()`

- Use `ctx.waitUntil()` (from the `ExecutionContext`) to run background work after the response is sent — analytics, logging, cache warming, webhook deliveries.
- `waitUntil()` extends the Worker's lifetime but does **not** block the response.
- Never put critical business logic in `waitUntil()` — if the runtime terminates early, the promise may not complete.

```ts
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const result = await handleRequest(request, env);

    // Fire-and-forget: log request analytics
    ctx.waitUntil(logToAnalytics(request, result, env));

    return Response.json(result);
  },
};
```

## CORS Configuration

- Handle `OPTIONS` preflight requests explicitly.
- Never use `Access-Control-Allow-Origin: *` for authenticated endpoints.
- Set `Access-Control-Max-Age` to reduce preflight frequency.

```ts
const corsHeaders = {
  "Access-Control-Allow-Origin": "https://yourdomain.com",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
  "Access-Control-Max-Age": "86400",
};

function handleOptions(request: Request): Response {
  return new Response(null, { status: 204, headers: corsHeaders });
}

function addCorsHeaders(response: Response): Response {
  const newResponse = new Response(response.body, response);
  Object.entries(corsHeaders).forEach(([key, value]) => {
    newResponse.headers.set(key, value);
  });
  return newResponse;
}
```

## Wrangler Configuration

- Always use `wrangler.toml` (or `wrangler.jsonc`) as the single source of truth for Worker configuration.
- Define all bindings (KV, R2, D1, Durable Objects, Queues, secrets) in `wrangler.toml` — never hardcode binding names or IDs.
- Use `[vars]` for non-secret configuration and `wrangler secret put` for secrets.
- Set `compatibility_date` to the latest stable date to access new APIs while ensuring reproducible behavior.

```toml
name = "my-worker"
main = "src/index.ts"
compatibility_date = "2025-12-01"

[vars]
ENVIRONMENT = "production"

[[kv_namespaces]]
binding = "MY_KV"
id = "abc123"

[[r2_buckets]]
binding = "BUCKET"
bucket_name = "my-bucket"

[[d1_databases]]
binding = "DB"
database_name = "my-database"
database_id = "def456"
```

## Environment Bindings

- Access all external resources (KV, R2, D1, Durable Objects, Queues, secrets, environment variables) through the `env` parameter — never use global variables or `process.env`.
- Type your `Env` interface to get full TypeScript IntelliSense and catch binding errors at compile time.

```ts
interface Env {
  MY_KV: KVNamespace;
  BUCKET: R2Bucket;
  DB: D1Database;
  MY_QUEUE: Queue;
  CHAT_ROOM: DurableObjectNamespace;
  API_SECRET: string;
  ENVIRONMENT: string;
}
```

## Module Worker Syntax

- **Always use ES module syntax** (the modern default). Service worker syntax is legacy and lacks access to environment bindings, Durable Objects, and Queues.

```ts
// ✅ Module syntax (recommended)
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    return new Response("Hello from module Worker!");
  },
};

// ❌ Service worker syntax (legacy — avoid)
// addEventListener("fetch", (event) => { ... });
```

## HTMLRewriter — Streaming HTML Transformation

- Use `HTMLRewriter` to transform HTML responses on the fly without buffering the entire document into memory.
- Common use cases: inject analytics scripts, rewrite links, localize content, add headers/footers, A/B testing.
- Handlers are streaming — they process elements as they are encountered, keeping memory usage constant.

```ts
// Inject a script tag before </head>
const rewriter = new HTMLRewriter()
  .on("head", {
    element(element) {
      element.append('<script src="/analytics.js"></script>', { html: true });
    },
  })
  .on("a[href]", {
    element(element) {
      const href = element.getAttribute("href");
      if (href?.startsWith("http://")) {
        element.setAttribute("href", href.replace("http://", "https://"));
      }
    },
  })
  .on("title", {
    text(text) {
      // Modify text content within <title> elements
      if (text.text) {
        text.replace(text.text.toUpperCase());
      }
    },
  });

// Apply the rewriter to an upstream response
const response = await fetch(request);
return rewriter.transform(response);
```

- **Do not** use HTMLRewriter on non-HTML responses — check `Content-Type` first.
- Chain multiple handlers for different selectors on the same `HTMLRewriter` instance.
- Use `element.onEndTag()` for inserting content at the closing tag.

## Cache API — Edge Caching

- Use the **Cache API** (`caches.default`) to cache responses at the Cloudflare edge.
- Cache API is separate from browser Cache-Control headers — it stores responses in Cloudflare's CDN.
- Only `GET` requests are cacheable by default. Use a custom cache key for dynamic content.

```ts
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const cache = caches.default;
    const cacheKey = new Request(request.url, request);

    // Check cache first
    let response = await cache.match(cacheKey);
    if (response) {
      return response;
    }

    // Fetch from origin
    response = await fetch(request);
    response = new Response(response.body, response);
    response.headers.set("Cache-Control", "s-maxage=3600");

    // Store in cache (non-blocking)
    ctx.waitUntil(cache.put(cacheKey, response.clone()));

    return response;
  },
};
```

## Performance Tips

- Return responses as early as possible — avoid unnecessary `await` chains.
- Use `Cache API` (`caches.default`) for caching expensive upstream responses at the edge.
- Use `HTMLRewriter` for efficient streaming HTML transformations without buffering the entire document.
- Prefer `Response.json()` over manually setting `Content-Type` and `JSON.stringify()`.
- Minimize global scope code — it runs on every cold start across all isolates.
- Parallelize independent I/O with `Promise.all()` instead of sequential `await`.
- Use streaming responses (`ReadableStream`) for large payloads instead of buffering.
