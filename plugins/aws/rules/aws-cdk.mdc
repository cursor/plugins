---
description: AWS CDK best practices for infrastructure-as-code projects
globs: ["lib/**/*.ts", "cdk/**/*.ts", "infra/**/*.ts"]
---

# AWS CDK Best Practices

## Use L2/L3 Constructs

- Prefer L2 (curated) and L3 (pattern) constructs over L1 (`Cfn*`) constructs whenever available.
- L2 constructs provide sensible defaults, helper methods, and grant-based IAM.
- Only drop to L1 constructs when L2 does not expose a required CloudFormation property.

```typescript
// ✅ L2 construct — sensible defaults, grant helpers
import * as s3 from "aws-cdk-lib/aws-s3";

const bucket = new s3.Bucket(this, "DataBucket", {
  versioned: true,
  encryption: s3.BucketEncryption.S3_MANAGED,
  removalPolicy: cdk.RemovalPolicy.RETAIN,
});

// ❌ L1 construct — verbose, no helpers
import * as s3 from "aws-cdk-lib/aws-s3";
const cfnBucket = new s3.CfnBucket(this, "DataBucket", { /* ... */ });
```

## Construct Library Patterns

- Organize infrastructure into reusable construct libraries with well-defined interfaces.
- Keep constructs single-purpose; compose larger architectures from smaller constructs.
- Export construct props interfaces for consumers to configure behavior.
- Document every construct with JSDoc comments.

```typescript
export interface ApiConstructProps {
  readonly tableName: string;
  readonly stageName?: string;
}

export class ApiConstruct extends Construct {
  public readonly api: apigateway.RestApi;

  constructor(scope: Construct, id: string, props: ApiConstructProps) {
    super(scope, id);
    // ...
  }
}
```

## Removal Policies

- Set `removalPolicy` explicitly on every stateful resource (databases, buckets, file systems).
- Use `RemovalPolicy.RETAIN` for production data stores to prevent accidental deletion.
- Use `RemovalPolicy.DESTROY` only in development or ephemeral stacks.
- Enable `autoDeleteObjects` on S3 buckets paired with `DESTROY` to avoid stack-delete failures.

## Tagging

- Tag all resources with at minimum: `Environment`, `Project`, `Owner`, and `ManagedBy: CDK`.
- Use `cdk.Tags.of(scope).add(key, value)` to apply tags at the stack or app level.
- Use tag-based cost allocation and access-control policies.

```typescript
cdk.Tags.of(app).add("ManagedBy", "CDK");
cdk.Tags.of(app).add("Project", "my-service");
cdk.Tags.of(app).add("Environment", props.environment);
```

## CDK Aspects for Compliance

- Use CDK Aspects to enforce organizational policies across all constructs in a scope.
- Common checks: encryption enabled, public access blocked, logging enabled.
- Run aspects at synth time to catch violations before deployment.

```typescript
import { Aspects, IAspect } from "aws-cdk-lib";

class BucketEncryptionChecker implements IAspect {
  public visit(node: IConstruct): void {
    if (node instanceof s3.Bucket) {
      if (!node.encryptionKey) {
        Annotations.of(node).addWarning("Bucket should use KMS encryption");
      }
    }
  }
}

Aspects.of(stack).add(new BucketEncryptionChecker());
```

## Stack Naming and Organization

- Use a consistent naming convention: `<Project>-<Environment>-<Component>Stack`.
- Keep stacks focused on a single domain (networking, compute, storage, monitoring).
- Use cross-stack references sparingly; prefer passing values through construct props.
- Set `stackName` explicitly to control CloudFormation stack names.

```typescript
new ApiStack(app, "MyService-Prod-ApiStack", {
  stackName: "myservice-prod-api",
  env: { account: "123456789012", region: "us-east-1" },
});
```

## Environment Configuration with CDK Context

- Use `cdk.json` context values or `-c` flags for environment-specific configuration.
- Access context values via `this.node.tryGetContext("key")`.
- Never hardcode account IDs, regions, or environment-specific values in construct code.

```typescript
const environment = this.node.tryGetContext("environment") ?? "dev";
const config = this.node.tryGetContext(environment);
```

## CDK Testing

- Write snapshot tests to detect unintended infrastructure drift.
- Write fine-grained assertion tests for critical resources using `aws-cdk-lib/assertions`.
- Test construct behavior, not just template output.

```typescript
import { Template } from "aws-cdk-lib/assertions";

test("creates DynamoDB table with PAY_PER_REQUEST billing", () => {
  const app = new cdk.App();
  const stack = new MyStack(app, "TestStack");
  const template = Template.fromStack(stack);

  template.hasResourceProperties("AWS::DynamoDB::Table", {
    BillingMode: "PAY_PER_REQUEST",
  });
});
```

## Security with cdk-nag

- Integrate `cdk-nag` into your CDK app to enforce AWS security best practices at synth time.
- Apply rule packs such as `AwsSolutionsChecks`, `NIST80053R5Checks`, or `HIPAASecurityChecks`.
- Suppress individual rules only with documented justification.

```typescript
import { AwsSolutionsChecks } from "cdk-nag";

Aspects.of(app).add(new AwsSolutionsChecks({ verbose: true }));
```
